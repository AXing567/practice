/*
C国有N座城市，编号为1到N。每座城市都有一个传送者，在编号为i的城市的传送者可以把你送到编号为Ai的城市.
你打算从1号城市出发，利用传送者进行环游。你想知道传送K次后，你会在哪座城市里。
输入格式
第一行有两个正整数N，K，表示有N座城市，一共要传送K次，（2≤N≤105   1≤K≤1018）
第二行有N个数字，表示每座城市的传送者可以将你送到Ai城市。(1≤Ai≤N)
输出格式
输出一个整数，表示你最后所在的城市。
样例输入
4 5
3 2 4 1
样例输出
4
*/
#include <iostream>
using namespace std;
const int N=1e5 + 10;

int pos[N],stk[N],idx,temp,start,n,st,rev[N];
//temp  表示循环的起点的值是什么
//start 表示stk数组里面循环的起点的下标
//idx   表示数组的长度（应该是第二种情况：进入重复部分城市的循环，的循环长度吧）
//st    表示现在在几号点（应该是当前所在城市的下标吧）
//rev   记录循环数组（即第二种情况，记录下来循环部分）

bool vis[N];//默认值为false
long long k;//k <= 1e18 ,所以用long long


int main()
{
    int ans;
    cin >> n >> k;
    for(int i=1;i<=n;i++){//从下标1到n，接收每座城市传送者的传送数据
        cin>>pos[i];
    }

    st = 1;

    while(true){//求“城市循环”的开始端、记录经过了哪些城市，最后落在了哪个城市
        if(vis[st]){//查看st这座城市是否来过，来过就代表进入了第二种情况“城市循环”，没来过就代表第一种情况“没有进入城市循环”
            temp= st;//
            break;
        }
        if(k==0){//当没有旅行次数就会输出当前所在城市的位置
            cout<<st;
        }

        stk[idx++]=st;
        vis[st]=true;//记录来过的st这座城市来过
        st=pos[st];
        k--;
    }
    for(int i=0;i<idx;i++){
        if(stk[i]==temp){
            start=i;//找到“城市循环”的第一个左端点
            break;
        }
    }
    for(int i=0,j=start;j<idx;i++,j++)
    {
        rev[i]=stk[j];//记录“城市循环”部分，如341  341  341  中的“3 4 1”
    }
    int len=idx-start;//“城市循环”的循环长度
    cout<<rev[k%len];//如果不是在“非城市循环”部分结束那就是在“城市循环”部分结束，既然到了这里，
                    // 就可以直接利用循环数组中直接计算出来最后的结果落在哪里
                    // 因为k已经在“非城市循环”的跳跃中消耗了对应次数，所以剩下的k就存储了在“城市循环”中还可以穿梭多少次
                    // 所以可以直接计算出来

    
    return 0;
}